package eu.nebulouscloud.optimiser.controller;

import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.BooleanNode;
import com.fasterxml.jackson.databind.node.LongNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.TextNode;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;

import eu.nebulouscloud.exn.core.Publisher;
import eu.nebulouscloud.optimiser.kubevela.KubevelaAnalyzer;
import eu.nebulouscloud.optimiser.sal.*;
import lombok.Getter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;


/**
 * Internal representation of a NebulOus app.
 */
@Slf4j
public class NebulousApp {

    /**
     * The UUID of the app. This identifies a specific application's ActiveMQ
     * messages, etc.  Chosen by the UI, unique across a NebulOuS
     * installation.
     */
    @Getter
    private String UUID;
    /**
     * The app name, a user-readable string.  Not guaranteed to be unique.
     * Might contain whitespace, unicode and everything else a user can type
     * into a form.
     */
    @Getter private String rawName;

    /**
     * A version of {@link #rawName} that is safe to use as a filename. Not
     * guaranteed to be unique.
     */
    @Getter private String name;

    /**
     * The cluster name.  This must be globally unique but should be short,
     * since during deployment it will be used to create instance names, where
     * AWS has a length restriction.  Generated by us.
     */
    @Getter private String clusterName;

    /**
     * The application status.
     *
     * <ul><li>NEW: The application has been created from the GUI and is
     * waiting for the performance indicators from the utility evaluator.
     *
     * <li>READY: The application is ready for deployment.
     *
     * <li>DEPLOYING: The application is being deployed or redeployed.
     *
     * <li>RUNNING: The application is running.
     *
     * <li>FAILED: The application is in an invalid state: one or more
     * messages could not be parsed, or deployment or redeployment failed.
     * </ul>
     *
     * <li>DELETED: The application has been deleted and is from now on
     * unknown to the optimiser-controller.  It is possible to send an app
     * creation message with the same UUID as the one that has been deleted.
     * </ul>
     */
    public enum State {
        NEW,
        READY,
        DEPLOYING,
        RUNNING,
        FAILED,
        DELETED;
    }

    @Getter
    private State state;

    // ----------------------------------------
    // App message parsing stuff

    /** Location of the kubevela yaml file in the app creation message (String) */
    private static final JsonPointer kubevela_path = JsonPointer.compile("/content");
    /** Location of the variables (optimizable locations) of the kubevela file
     * in the app creation message. (Array of objects) */
    private static final JsonPointer variables_path = JsonPointer.compile("/variables");
    /** Locations of the UUID and name in the app creation message (String) */
    private static final JsonPointer uuid_path = JsonPointer.compile("/uuid");
    private static final JsonPointer name_path = JsonPointer.compile("/title");
    private static final JsonPointer utility_function_path = JsonPointer.compile("/utilityFunctions");
    private static final JsonPointer constraints_path = JsonPointer.compile("/sloViolations");
    
    

    /** The YAML converter */
    // Note that instantiating this is apparently expensive, so we do it only once
    private static final ObjectMapper yamlMapper = new ObjectMapper(new YAMLFactory());

    /** General-purpose object mapper */
    @Getter
    private static final ObjectMapper jsonMapper = new ObjectMapper();

    // ----------------------------------------
    // Solver message stuff

    // These two property names come from the solver solution message; not
    // owned by us.
    private static final String DEPLOY_PROPERTY = "DeploySolution";
    private static final String VARIABLEVALUES_PROPERTY = "VariableValues";

    // ----------------------------------------
    // AMPL stuff

    /** The array of KubeVela variables in the app message. */
    @Getter private Map<String, JsonNode> kubevelaVariables = new HashMap<>();
    /** The app's raw metrics, a map from key to the defining JSON node. */
    @Getter private Map<String, JsonNode> rawMetrics = new HashMap<>();
    /** The app's composite metrics, a map from key to the defining JSON node. */
    @Getter private  Map<String, JsonNode> compositeMetrics = new HashMap<>();
    /** The app's performance indicators, a map from key to the defining JSON node. */
    @Getter private Map<String, JsonNode> performanceIndicators = new HashMap<>();
    /** The app's "relevant" performance indicators, as calculated by the
     * utility evaluator.  Initialized to empty object for testing purposes. */
    @Getter private JsonNode relevantPerformanceIndicators = jsonMapper.createObjectNode();
    /** The app's utility functions; the AMPL solver will optimize for one of these. */
    @Getter private Map<String, JsonNode> utilityFunctions = new HashMap<>();
    /**
     * The constraints that are actually relevant for the optimizer.  If a
     * constraint does not contain a variable, we cannot influence it via the
     * solver, so it should not be included in the AMPL file.
     */
    @Getter private Set<JsonNode> effectiveConstraints = new HashSet<>();
    /**
     * The constraints that are specified in the `utilityFunctions` array,
     * with a `type` of `constraint`.
     */
    @Getter private Set<JsonNode> specifiedConstraints = new HashSet<>();

    // ----------------------------------------
    // Deployment stuff

    /**
     * The EXN connector for this class.  At the moment all apps share the
     * same instance, but probably every app should have their own, out of
     * thread-safety concerns.
     */
    @Getter
    private ExnConnector exnConnector;

    /** The original app message. */
    @Getter
    private final JsonNode originalAppMessage;

    /**
     * A map from cloud name to its regions, for all clouds where components
     * of this application can be deployed. This information comes from the
     * `resources` section of the app message; we collect all cloud IDs where
     * `enabled:true` holds, each mapped to the regions specified for that
     * cloud, or an empty set if no regions specified.
     */
    @Getter private Map<String, Set<String>> clouds;

    /**
     * The original kubevela.  Might be {@code null} in case the original app
     * message sent an unparseable kubevela file; the app will be in state
     * FAILED.
     */
    @Getter
    private final ObjectNode originalKubevela;
    
    /**
     * Current version of the kubevela. It is the originalKubevela with variable values dictated by solver.
     * It is different from deployedKubevela
     */
    @Getter
    private ObjectNode currentKubevela;

    /**
     * The KubeVela sent to the app's controller node for the currently active
     * deployment.
     */
    @Getter
    private JsonNode deployedKubevela = null;

    /**
     * The current "generation" of deployment.  Initial deployment sets this
     * to 1, each subsequent redeployment increases by 1.  This value is used
     * to name node instances generated during that deployment.
     */
    @Getter
    private int deployGeneration = 0;

    /**
     * Map of component name to its requirements, for the currently active
     * deployment.
     */
    @Getter
    private Map<String, List<Requirement>> componentRequirements = Map.of();

    /** Map of component name to its replica count, as currently deployed. */
    @Getter
    private Map<String, Integer> componentReplicaCounts = Map.of();

    /**
     * Map of component name to node candidate(s) for that component, as
     * computed during the most recent deployment or redeployment.  We keep
     * track of the node candidates so we can redeploy if the CFSB finds more
     * suitable node candidates for the given component, even if the component
     * requirements did not change.
     *
     * <p>For the master node, we use its node name instead of the nonexistent
     * KubeVela component name.
     */
    @Getter
    private Map<String, List<NodeCandidate>> suggestedNodeCandidates = Map.of();

    /**
     * Map of component name to node name(s) deployed for that component.
     * Component names are defined in the KubeVela file.  We assume that
     * component names stay constant during the app's lifecycle, i.e., once an
     * application is deployed, its components will not change.
     */
    @Getter
    private Map<String, Set<String>> componentNodeNames = Map.of();

    /**
     * Map from node name to actually deployed node candidate.  The mapping
     * from KubeVela component to node name(s) can be found in {@link
     * #componentNodeNames}.
     */
    @Getter
    private Map<String, NodeCandidate> deployedNodeCandidates = Map.of();


    /** Scheduled executor service for periodic health checks */
    private ScheduledExecutorService healthCheckExecutor = null;
    
    /** Interval in seconds between health checks */
    private static final int HEALTH_CHECK_INTERVAL_SECONDS = 30;

    /**
     * Creates a NebulousApp object.
     *
     * @param app_message The whole app creation message (JSON)
     * @param kubevela_string The deployable KubeVela App model (YAML string)
     * @param ampl_message_channel A publisher for sending the generated AMPL file, or null
     */
    // Example KubeVela and parameter files can be found at
    // optimiser-controller/src/test/resources/
    public NebulousApp(JsonNode app_message, String kubevela_string, ExnConnector exnConnector) {
        this.UUID = app_message.at(uuid_path).textValue();
        this.rawName = app_message.at(name_path).textValue();
        this.name = rawName.replaceAll("[^a-zA-Z0-9-_]", "_");
        this.state = State.NEW;
        this.clusterName = NebulousApps.calculateUniqueClusterName(this.UUID);
        this.originalAppMessage = app_message;
        ObjectNode kubevela = null;
	try {
	    kubevela = (ObjectNode)readKubevelaString(kubevela_string);
	} catch (JsonProcessingException e) {
            this.state = State.FAILED;
            this.originalKubevela = null;
            log.error("Could not parse KubeVela YAML in app creation message: " + e.getMessage());
            return;
	}
        this.originalKubevela = kubevela;
        this.exnConnector = exnConnector;
        JsonNode parameters = app_message.at(variables_path);
        if (parameters.isArray()) {
            for (JsonNode p : parameters) {
                kubevelaVariables.put(p.get("key").asText(), p);
            }
        } else {
            log.error("Cannot read parameters from app message, continuing without parameters");
        }
        for (JsonNode f : originalAppMessage.withArray(utility_function_path)) {
            if (f.at("/type").asText().equals("constraint")) {
                specifiedConstraints.add(f);
            } else {
                utilityFunctions.put(f.at("/name").asText(), f);
            }
        }

        // We need to know which metrics are raw, composite, and which ones
        // are performance indicators in disguise.
        boolean done = false;
        Set<JsonNode> metrics = StreamSupport.stream(
            Spliterators.spliteratorUnknownSize(
                app_message.withArray("/metrics").elements(),
                Spliterator.ORDERED), false)
            .collect(Collectors.toSet());
        while (!done) {
            // Pick out all raw metrics.  Then pick out all composite metrics
            // that only depend on raw metrics and composite metrics that only
            // depend on raw metrics.  The rest are performance indicators.
            done = true;
            Iterator<JsonNode> it = metrics.iterator();
            while (it.hasNext()) {
                JsonNode m = it.next();
                if (m.get("type").asText().equals("raw")) {
                    rawMetrics.put(m.get("name").asText(), m);
                    it.remove();
                    done = false;
                } else {
                    ArrayNode arguments = m.withArray("arguments");
                    boolean is_composite_metric = StreamSupport.stream(
                        Spliterators.spliteratorUnknownSize(arguments.elements(), Spliterator.ORDERED), false)
                        .allMatch(o -> rawMetrics.containsKey(o.asText()) || compositeMetrics.containsKey(o.asText()));
                    if (is_composite_metric) {
                        compositeMetrics.put(m.get("name").asText(), m);
                        it.remove();
                        done = false;
                    }
                }
            }
        }
        for (JsonNode m : metrics) {
            // What's left is neither a raw nor composite metric.
            performanceIndicators.put(m.get("name").asText(), m);
        }
        for (JsonNode f : app_message.withArray(utility_function_path)) {
            // What's left is neither a raw nor composite metric.
            utilityFunctions.put(f.get("name").asText(), f);
        }
        for (String key : app_message.withObject(constraints_path).findValuesAsText("metricName")) {
            // In the current app message, `constraints` is not an array.
            // When this changes, wrap this for loop in another loop over the
            // constraints (Constraints are called sloViolations in the app
            // message).
            if (kubevelaVariables.keySet().contains(key) || performanceIndicators.keySet().contains(key)) {
                // Only consider the constraint if it uses at least one
                // variable (directly or via performance indicators).
                effectiveConstraints.add(app_message.withObject(constraints_path));
                break;
            }
        }
        clouds = StreamSupport.stream(
            Spliterators.spliteratorUnknownSize(
                app_message.withArray("/resources").elements(),
                Spliterator.ORDERED), false)
            .filter((c) -> c.at("/enabled").asBoolean())
            .collect(Collectors.toMap(
                (c) -> c.at("/uuid").asText(),
                (c) -> Arrays.stream(c.at("/regions").asText().split(","))
                    .filter(regionName -> !regionName.isBlank())
                    .filter(regionName -> !regionName.equals("null")) // https://github.com/eu-nebulous/optimiser-controller/issues/56
                    .collect(Collectors.toSet())));
        if (clouds.isEmpty()) {
            log.error("No enabled clouds given in app creation message, setting app status to FAILED and aborting deployment.");
            this.setStateFailed(List.of());
        } else {
            log.debug("New App instantiated.");
        }
    }

    /**
     * Create a NebulousApp object given an app creation message parsed into
     * JSON.
     *
     * <p>Note that the result should be registered via {@link
     * NebulousApps#add} afterwards.  This is not done automatically since
     * registering an app happens on the hot path inside a mutex.
     *
     * @param app_message the app creation message, including valid KubeVela
     *  YAML et al
     * @param exnConnector The EXN connector to use for sending messages to
     *  the solver etc.
     * @return a NebulousApp object, or null if `app_message` could not be
     *  parsed
     */
    public static NebulousApp newFromAppMessage(JsonNode app_message, ExnConnector exnConnector) {
        try {
            String kubevela_string = app_message.at(kubevela_path).textValue();
            String UUID = app_message.at(uuid_path).textValue();
            JsonNode parameters = app_message.at(variables_path);
            if (kubevela_string == null || !parameters.isArray()) {
                log.error("Could not find kubevela or parameters in app creation message");
                return null;
            } else {
                Main.logFile("incoming-kubevela-" + UUID + ".yaml", kubevela_string);
                NebulousApp result = new NebulousApp(app_message, kubevela_string, exnConnector);
                return result;
            }
        } catch (Exception e) {
            log.error("Could not read app creation message", e);
            return null;
        }
    }

    /**
     * Set the state from NEW to READY, adding the list of relevant
     * performance indicators.  Return false if state was not READY.
     */
    @Synchronized
    public boolean setStateReady(JsonNode relevantPerformanceIndicators) {
        if (state != State.NEW) {
            return false;
        } else {
            state = State.READY;
            this.relevantPerformanceIndicators = relevantPerformanceIndicators;
            exnConnector.sendAppStatus(UUID, state);
            return true;
        }
    }

    /**
     * Set the state from READY to DEPLOYING, and increment the generation.
     *
     * @return false if deployment could not be started, true otherwise.
     */
    @Synchronized
    public boolean setStateDeploying() {
        if (state != State.READY) {
            return false;
        } else {
            state = State.DEPLOYING;
            deployGeneration++;
            exnConnector.sendAppStatus(UUID, state);
            return true;
        }
    }

    /**
     * If app is in the DEPLOYING state, sends a DEPLOYING state message, with
     * the cluster status as reported by SAL.  Otherwise does nothing.
     *
     * @param clusterStatus a JSON node with the cluster status returned by
     *  the getCluster endpoint.
     * @return true if status message sent, false otherwise.
     */
    @Synchronized
    public boolean sendDeploymentStatus(JsonNode clusterState, Map<String,Object> additionalEntries) {
        if (state == State.DEPLOYING) {
            exnConnector.sendAppStatus(UUID, state,additionalEntries);
            return true;
        } else {
            return false;
        }
    }
    
    public static Map<String,Object> buildAppStatusReport(
    		String clusterName,
    		int deployGeneration,
    		  Map<String, List<Requirement>> componentRequirements,
    	        Map<String, Integer> nodeCounts,
    	        Map<String, Set<String>> componentNodeNames,
    	        Map<String, NodeCandidate> deployedNodeCandidates)
    {
    	Map<String,Object> appStatusReport = new HashMap<>();
    	try {
    	
	        appStatusReport.put("clusterName", clusterName);
	        appStatusReport.put("deployGeneration", deployGeneration);
	        Map<String,Object> components= new HashMap<>();
	        appStatusReport.put("components",components);
	        for(String componentName : componentNodeNames.keySet()) {
	            Map<String,Object> componentStatusReport = new HashMap<>();
	            componentStatusReport.put("componentName", componentName);
	
	            if(componentRequirements.containsKey(componentName)) {
	                componentStatusReport.put("componentRequirements", componentRequirements.get(componentName));
	            } else {
	                componentStatusReport.put("componentRequirements", new LinkedList<>());
	            }
	            if(nodeCounts.containsKey(componentName)) {
	                componentStatusReport.put("nodeCount", nodeCounts.get(componentName));
	            } else {
	                componentStatusReport.put("nodeCount", 0);
	            }
	            LinkedList<NodeCandidate> deployedNodes = new LinkedList<NodeCandidate>();
	            componentStatusReport.put("deployedNodes",deployedNodes);
	            componentNodeNames.get(componentName).forEach(nodeCandidate -> {
	                if(deployedNodeCandidates.containsKey(nodeCandidate)) {
	                	deployedNodes.add(deployedNodeCandidates.get(nodeCandidate));
	                }
	            });                

	            components.put(componentName, componentStatusReport);
	        }
            NodeCandidate master = deployedNodeCandidates.entrySet().stream().filter(n->n.getKey().startsWith("m"+clusterName+"-master")).findFirst().get().getValue();
            
            appStatusReport.put("master",master);	
	        ObjectMapper om = new ObjectMapper();
	       
	        	return om.readValue(om.writeValueAsString(Map.of("details",appStatusReport)), new HashMap().getClass());
			} catch (Exception ex) {
				log.error("Failed to build appStatusReport",ex);
			}
        return new HashMap<String, Object>();
        
    }

    /** Set state from DEPLOYING to RUNNING and update app cluster information.
      * @return false if not in state deploying, otherwise true. */
    @Synchronized
    public boolean setStateDeploymentFinished(
        Map<String, List<Requirement>> componentRequirements,
        Map<String, Integer> nodeCounts,
        Map<String, Set<String>> componentNodeNames,
        Map<String, List<NodeCandidate>> suggestedNodeCandidates,
        Map<String, NodeCandidate> deployedNodeCandidates,
        JsonNode deployedKubevela)
    {
        if (state != State.DEPLOYING) {
            return false;
        } else {
            // We keep all state read-only so we cannot accidentally modify
            // part of the app object's state before we know deployment is
            // successful
            this.componentRequirements = Map.copyOf(componentRequirements);
            this.componentReplicaCounts = Map.copyOf(nodeCounts);
            this.componentNodeNames = Map.copyOf(componentNodeNames);
            this.suggestedNodeCandidates = Map.copyOf(suggestedNodeCandidates);
            this.deployedKubevela = deployedKubevela;
            this.deployedNodeCandidates = Map.copyOf(deployedNodeCandidates);
            state = State.RUNNING;
            Map<String,Object> appStatusReport = buildAppStatusReport(clusterName, deployGeneration, componentRequirements, nodeCounts, componentNodeNames, deployedNodeCandidates);
            exnConnector.sendAppStatus(UUID, state,appStatusReport);
            
            // Start health monitoring when app reaches RUNNING state
            startHealthMonitoring();
            
            return true;
        }
    }

    /**
     * Set the state from RUNNING to DEPLOYING, and increment the generation.
     *
     * @return false if redeployment could not be started, true otherwise.
     */
    @Synchronized
    public boolean setStateRedeploying() {
        if (state != State.RUNNING) {
            return false;
        } else {
            state = State.DEPLOYING;
            deployGeneration++;
            exnConnector.sendAppStatus(UUID, state);
            return true;
        }
    }

    /**
     * Set state unconditionally to FAILED.  The only state change possible in
     * this state is reset to READY.  Also release the given acquired (edge)
     * nodes.
     *
     * @param acquiredNodes The edge nodes to release
     */
    public void setStateFailed(Collection<NodeCandidate> acquiredNodes) {
        EdgeNodes.release(this.UUID, acquiredNodes);
        if (state == State.DELETED) return;
        
        // Stop health monitoring when app fails
        stopHealthMonitoring();
        
        state = State.FAILED;
        exnConnector.sendAppStatus(UUID, state);
    }

    /**
     * Reset the app object's state.  Removes all information about the
     * current deployment, and makes it possible to redo initial deployment.
     *
     * <p>Note: this method can be called no matter which state the
     * application object is in (except DELETED), but removing a running app
     * cluster, if it exists, is the responsibility of whoever calls this
     * method.
     */
    @Synchronized
    public void resetState() {
        if (state == State.DELETED) return;
        
        // Stop health monitoring when resetting state
        stopHealthMonitoring();
        
        this.deployGeneration = 0;
        this.componentRequirements = Map.of();
        this.componentReplicaCounts = Map.of();
        this.componentNodeNames = Map.of();
        this.suggestedNodeCandidates = Map.of();
        this.deployedKubevela = null;
        this.deployedNodeCandidates = Map.of();
        state = State.READY;
        exnConnector.sendAppStatus(UUID, state);
    }

    /**
     * Set state to DELETED and unregister this application via {@link
     * NebulousApps#remove}.  Note that this method does not try to stop the
     * application's cluster in case it is running.
     */
    @Synchronized
    public void setStateDeletedAndUnregister() {
        // Stop health monitoring before deleting
        stopHealthMonitoring();
        
        state = State.DELETED;
        NebulousApps.remove(UUID);
        exnConnector.sendAppStatus(UUID, state);
    }

    /** Utility function to parse a KubeVela string.  Can be used from jshell. */
    public static JsonNode readKubevelaString(String kubevela) throws JsonMappingException, JsonProcessingException {
        return yamlMapper.readTree(kubevela);
    }

    /** Utility function to parse KubeVela from a file.  Intended for use from jshell.
     * @throws IOException
     * @throws JsonProcessingException
     * @throws JsonMappingException */
    public static JsonNode readKubevelaFile(String path) throws JsonMappingException, JsonProcessingException, IOException {
        return readKubevelaString(Files.readString(Path.of(path), StandardCharsets.UTF_8));
    }

    /**
     * Check that all parameters have a name, type and path, and that the
     * target path can be found in the original KubeVela file.
     *
     * @return true if all requirements hold, false otherwise
     */
    public boolean validatePaths() {
        for (final JsonNode param : kubevelaVariables.values()) {
            String param_name = param.get("key").textValue();
            if (param_name == null || param_name.equals("")) return false;
            String param_type = param.get("type").textValue();
            if (param_type == null || param_type.equals("")) return false;
            // TODO: also validate types, upper and lower bounds, etc.
            String target_path = param.get("path").textValue();
            if (target_path == null || target_path.equals("")) return false;
            JsonNode target = findPathInKubevela(target_path);
            if (target == null) return false; // must exist
        }
        return true;
    }

    /**
     * Return the location of a path in the application's KubeVela model.
     *
     * See https://datatracker.ietf.org/doc/html/rfc6901 for a specification
     * of the path format.
     *
     * @param path the path to the requested node, in JSON Pointer notation.
     * @return the node identified by the given path, or null if the path
     * cannot be followed
     */
    private JsonNode findPathInKubevela(String path) {
        JsonNode result = originalKubevela.at(path);
        return result.isMissingNode() ? null : result;
    }

    /**
     * Replace variables in the original KubeVela with values calculated by
     * the solver.  We look up the paths of the variables in the `parameters`
     * field.
     *
     * @param variableValues A JSON object with keys being variable names and
     *  their values the replacement value, for example:
     *
     *  <pre>{@code
     * {
     *   'spec_components_0_traits_0_properties_cpu': 8,
     *   'spec_components_0_traits_0_properties_memory': 4906
     * }
     * }</pre>
     *
     *  The variable names are generated by the UI and are cross-referenced
     *  with locations in the KubeVela file.
     *
     * @return the modified KubeVela YAML, or null if no KubeVela could be
     *  generated.
     */
    public ObjectNode rewriteKubevelaWithSolution(ObjectNode variableValues) {
        ObjectNode freshKubevela = originalKubevela.deepCopy();
        for (Map.Entry<String, JsonNode> entry : variableValues.properties()) {
            String key = entry.getKey();
            JsonNode replacementValue = entry.getValue();
            JsonNode param = kubevelaVariables.get(key);
            // The solver sends all defined AMPL variables, not only the ones
            // that correspond to KubeVela locations
            if (param == null) continue;
            String pathstr = param.at("/path").asText();
            // The "application_deployment_price" variable (with meaning:
            // "price"), does not have a KubeVela path associated.
            if (pathstr == null || pathstr.isEmpty()) continue;
            JsonPointer path = JsonPointer.compile(pathstr);
            JsonNode nodeToBeReplaced = freshKubevela.at(path);
            boolean doReplacement = true;

            if (nodeToBeReplaced == null) {
                // Didn't find location in KubeVela file (should never happen)
                log.warn("Location {} not found in KubeVela, cannot replace with value {}",
                    key, replacementValue);
                doReplacement = false;
            } else {
                String meaning = param.at("/meaning").asText();
                if (KubevelaAnalyzer.isKubevelaInteger(meaning) && replacementValue.isFloatingPointNumber()) {
                    // Workaround for
                    // https://github.com/eu-nebulous/optimiser-controller/issues/119
                    // -- we didn't get the dsl file so we can't check if we
                    // (in the AMPL file) or the solver in its return value
                    // produce the stray float value.
                    replacementValue = new LongNode(replacementValue.asLong());
                }
                if (meaning.equals("memory")) {
                    // Special case: the solver delivers a number for memory, but
                    // KubeVela wants a number with a unit, so we have to add one.
                    // Also, we have cases where the initial node size is
                    // specified in GB but the formulas and boundaries are
                    // expressed in MB (and vice versa), so we have to use a
                    // heuristic for guessing which unit the user meant.
                    if (!(replacementValue.asText().endsWith("Mi")
                          || replacementValue.asText().endsWith("Gi"))) {
                        if (replacementValue.asDouble() <= 512) {
                            replacementValue = new TextNode(replacementValue.asText() + "Gi");
                        } else {
                            replacementValue = new TextNode(replacementValue.asText() + "Mi");
                        }
                    }
                }
            }              // Handle other special cases here, as they come up
            if (doReplacement) {
                ObjectNode parent = (ObjectNode)freshKubevela.at(path.head());
                String property = path.last().getMatchingProperty();
                parent.replace(property, replacementValue);
            }
        }
        return freshKubevela;
    }

    /**
     * Create a synthetic solver solution message from a kubevela file.
     *
     * <p>This is the reverse to {@link #rewriteKubevelaWithSolution}.  It is
     * used during initial deployment to generate an initial "solution"
     * message to send to EMS.  The message will have an entry {@code
     * DeploySolution: false}, just to make sure we don't try to redeploy
     * immediately.
     *
     * @param kubevela The kubevela file holding the variable values.
     * @return A synthetic solver solution message.
     */
    public ObjectNode createSolutionFromKubevela(JsonNode kubevela) {
        ObjectNode syntheticSolution = jsonMapper.createObjectNode();
        syntheticSolution.put(DEPLOY_PROPERTY, false);
        ObjectNode variableValues = syntheticSolution.withObjectProperty(VARIABLEVALUES_PROPERTY);
        for (JsonNode variable : kubevelaVariables.values()) {
            String name = variable.at("/key").asText();
            String locationstr = variable.at("/path").asText();
            // the "application_deployment_price" variable has an empty path
            if (locationstr == null || locationstr.isEmpty()) continue;
            var location = JsonPointer.compile(locationstr);
            JsonNode value = kubevela.at(location);
            if (!value.isMissingNode()) {
                variableValues.set(name, value);
            }
        }
        return syntheticSolution;
    }

    /**
     * Calculate the AMPL message to send to the solver.
     */
    public JsonNode calculateAMPLMessage() {
        String ampl_model = AMPLGenerator.generateAMPL(this,
            this.deployedKubevela == null ? this.originalKubevela : this.deployedKubevela);
        String ampl_data = relevantPerformanceIndicators.at("/initialDataFile").textValue();
        ObjectNode msg = jsonMapper.createObjectNode();

        msg.put("ModelFileName", getUUID() + ".ampl");
        msg.put("ModelFileContent", ampl_model);
        if (ampl_data != null && ampl_data.length() > 0) {
            msg.put("DataFileName", getUUID() + ".dat");
            msg.put("DataFileContent", ampl_data);
        }
        msg.put("ObjectiveFunction", getSelectedUtilityFunction());
        ObjectNode constants = msg.withObject("Constants");
          // Define initial values for constant utility functions:
          // "Constants" : {
          //   <constant utility function name> : {
          //        "Variable" : <AMPL Variable Name>
          //        "Value"    : <value at the variable's path in original KubeVela>
          //   }
          // }
        for (final JsonNode function : originalAppMessage.withArray(utility_function_path)) {
            if (!(function.get("type").asText().equals("constant")))
                continue;
            // NOTE: for a constant function, we rely on the fact that the
            // function body is a single variable defined in the "Variables"
            // section and pointing to KubeVela, and the
            // `functionExpressionVariables` array contains one entry.
            JsonNode functionVariable = function.withArray("/expression/variables").get(0);
            String variableName = functionVariable.get("value").asText();
            JsonNode variable = this.getKubevelaVariables().getOrDefault(variableName, jsonMapper.missingNode());
            // Not all constants might be references to kubevela locations;
            // skip if we don't find an entry
            if (variable.isMissingNode()) continue;
            // The "application_deployment_price" variable has no kubevela
            // path and hence no value; skip it
            if (variable.at("/path").asText().isEmpty()) continue;
            JsonPointer path = JsonPointer.compile(variable.at("/path").asText());
            JsonNode value = originalKubevela.at(path);
            ObjectNode constant = constants.withObject(function.at("/name").asText());
            constant.put("Variable", variableName);
            String meaning = variable.at("/meaning").asText("unknown");
            if (KubevelaAnalyzer.isKubevelaInteger(meaning)) {
                // kubevelaNumberToLong handles converting "8Gi" to 8192 for
                // meaning "memory", and rounds up kubevela cpu/gpu (floating
                // point) to SAL number of cores (int) for meaning "cpu"
                constant.put("Value", KubevelaAnalyzer.kubevelaNumberToLong(value, meaning));
            } else {
                constant.set("Value", value);
            }
        }
        return msg;
    }

    /**
     * Calculate AMPL file and send it off to the solver.
     *
     * @param solverMessage The JSON message to the solver, as produced by
     *  {@link #calculateAMPLMessage()}.
     */
    public void sendAMPL(JsonNode solverMessage) {
        log.info("Sending AMPL files to solver");
        exnConnector.getAmplMessagePublisher().send(jsonMapper.convertValue(solverMessage, Map.class), getUUID(), true);
        Main.logFile("to-solver-" + getUUID() + ".json", solverMessage.toPrettyString());
        Main.logFile("to-solver-" + getUUID() + ".ampl",
            solverMessage.at("/ModelFileContent").asText());
    }

    /**
     * Send the metric list for the given app.  This is done two times: once
     * before app cluster creation to initialize EMS, once after cluster app
     * creation to initialize the solver.
     *
     * @param app The application under deployment.
     */
    public void sendMetricList() {
        Publisher metricsChannel = exnConnector.getMetricListPublisher();
        ObjectNode msg = jsonMapper.createObjectNode();
        ArrayNode metricNames = msg.withArray("/metrics");
        AMPLGenerator.getMetricList(this).forEach(metricNames::add);
        log.info("Sending metric list");
        metricsChannel.send(jsonMapper.convertValue(msg, Map.class), getUUID(), true);
        Main.logFile("metric-names-" + getUUID() + ".json", msg.toPrettyString());
    }

    /**
     * Return the utility function to use.  A utility function is a function
     * of type "minimize" or "maximize" in the {@code /utilityFunctions} array
     * of the app creation message.  (That array also contains functions of
     * type "constraint" or "constant", which are not utility functions.)
     *
     * <p>The function selected by the user contains a "selected: true" flag.
     * In case of multiple entries with that flag, return the first one; if no
     * entry has that flag, return the first entry.
     *
     * @return the utility function specified in the app creation message, or
     *  an empty string if none found.
     */
    private String getSelectedUtilityFunction() {
        ArrayNode utility_functions = originalAppMessage.withArray(utility_function_path);
        JsonNode maybeFunction = null;
        for (final JsonNode function : utility_functions) {
            if (!(function.at("/type").asText().equals("minimize")
                  || function.at("/type").asText().equals("maximize")))
                continue;
            if (maybeFunction == null) maybeFunction = function;
            if (function.at("/selected").asBoolean(false))
                return function.at("/name").asText();
        }
        if (maybeFunction != null) {
            String result = maybeFunction.at("/name").asText();
            log.warn("No utility function selected in GUI; continuing with {} (the first function)",
                result);
            return result;
        } else {
            log.error("No utility function specified; continuing deployment but no optimization is possible.");
            return "";
        }
    }

    /**
     * Handle an incoming solver message.  If the message has a field {@code
     * DeploySolution} with value {@code true}, rewrite the original KubeVela
     * file with the contained variable values and perform initial deployment
     * or redeployment as appropriate.  Otherwise, ignore the message.
     *
     * @param solution The message from the solver, containing a field
     *  "VariableValues" that can be processed by {@link
     *  NebulousApp#rewriteKubevelaWithSolution}.
     */
    @Synchronized
    public void redeployWithSolution(ObjectNode solution) {
        if (!solution.has(DEPLOY_PROPERTY)) {
            log.warn("Received solver solution without DeploySolution field, ignoring.");
            return;
        }
        if (!solution.at("/DeploySolution").asBoolean(false)) {
            // `asBoolean` returns its argument if node is missing or cannot
            // be converted to Boolean
            log.info("Received solver solution with DeploySolution=false, ignoring.");
            return;
        }
        
        ObjectNode variables = solution.withObjectProperty(VARIABLEVALUES_PROPERTY);
        ObjectNode kubevela = rewriteKubevelaWithSolution(variables);
        currentKubevela = kubevela.deepCopy();
        if (deployGeneration > 0) {
            NebulousAppDeployer.redeployApplication(this, kubevela);
        } else {
            // Since the solver is started as part of the initial deployment
            // this branch is effectively dead code -- but in case the overall
            // deployment flow changes and we somehow obtain a solution before
            // deployment, can't hurt to do this.
            log.warn("App received a solver solution before being deployed, this is unexpected. Boldly moving forward with initial deployment.");
            NebulousAppDeployer.deployApplication(this, kubevela);
        }
    }

    /**
     * Perform initial deployment.
     */
    @Synchronized
    public void deploy() {
    	currentKubevela = getOriginalKubevela().deepCopy();
        NebulousAppDeployer.deployApplication(this, getOriginalKubevela());
        
    }

    
    /**
     * Check if the app nodes are alive. If not, redeploy the application.
     */
    public void appHealthCheck() {
        try {
            if (state != State.RUNNING) {
                return;
            }

            List<String> deadNodeNames = exnConnector.getAppDeadNodes(UUID, clusterName);
            if (deadNodeNames.isEmpty()) {
                log.info("All nodes are alive, no redeployment needed");
                return;
            }
            log.info("Some nodes are missing: {}, redeploying application",
                    deadNodeNames.stream().collect(Collectors.joining(", ")));
            NebulousAppDeployer.redeployApplication(this, currentKubevela.deepCopy());
        }catch(Exception ex)
        {
        	log.error("Failed appHealthCheck",ex);
        }
        finally {
            healthCheckExecutor.schedule(
                    this::appHealthCheck,
                    HEALTH_CHECK_INTERVAL_SECONDS,
                    TimeUnit.SECONDS);
            log.debug("Scheduling health check for app {} in {} seconds", UUID, HEALTH_CHECK_INTERVAL_SECONDS);
        }
    }

    /**
     * Start the periodic health monitoring thread.
     */
    public void startHealthMonitoring() {       	
    	if(healthCheckExecutor==null) {
	        log.info("Starting health monitoring thread for app {}", UUID);
	        healthCheckExecutor = Executors.newSingleThreadScheduledExecutor(r -> {
	            Thread t = new Thread(r, "health-monitor-" + UUID);
	            t.setDaemon(true);
	            return t;
	        });
    	}
       
        healthCheckExecutor.schedule(
            this::appHealthCheck,
            HEALTH_CHECK_INTERVAL_SECONDS,
            TimeUnit.SECONDS
        ); 
        log.debug("Scheduling health check for app {} in {} seconds", UUID, HEALTH_CHECK_INTERVAL_SECONDS);
    }

    /**
     * Stop the periodic health monitoring thread.
     * This method is safe to call multiple times.
     */
    @Synchronized
    public void stopHealthMonitoring() {
        if (healthCheckExecutor != null && !healthCheckExecutor.isShutdown()) {
            healthCheckExecutor.shutdown();
            try {
                if (!healthCheckExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                    healthCheckExecutor.shutdownNow();
                    log.warn("Health monitoring thread for app {} did not terminate gracefully", UUID);
                } else {
                    log.info("Stopped health monitoring for app {}", UUID);
                }
            } catch (InterruptedException e) {
                healthCheckExecutor.shutdownNow();
                Thread.currentThread().interrupt();
                log.warn("Interrupted while stopping health monitoring for app {}", UUID);
            }
            healthCheckExecutor = null;
        }
    }
}
